{"version":3,"sources":["demo/utilities/parser/BaseParser.ts"],"names":[],"mappings":"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","file":"demo/utilities/parser/BaseParser.js","sourcesContent":["\r\n/**\r\n * Base for a parser - does not actually do any parsing.\r\n */\r\nexport class BaseParser {\r\n  private _currLocation = 0;\r\n  private _str: string;\r\n  private _strLength: number;\r\n\r\n  public constructor(_str: string) {\r\n    this._str = _str;\r\n    this._strLength = _str.length;\r\n  }\r\n\r\n  protected eat(match: string): string {\r\n    if (this._str.charAt(this._currLocation) === match) {\r\n      return this._str.charAt(this._currLocation++);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  protected eatSpacesAndNewlines(): string {\r\n    return this.eatWhileRegex(/[ \\r\\n]/);\r\n  }\r\n\r\n  protected eatWhile(match: string): string {\r\n    let i = 0;\r\n\r\n    while (this._str.charAt(this._currLocation + i) === match) {\r\n      i++;\r\n      if (i + this._currLocation > this._strLength) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this._currLocation += i;\r\n    return this._str.substr(this._currLocation - i, i);\r\n  }\r\n\r\n  protected eatWhileRegex(match: RegExp): string {\r\n    let i = 0;\r\n\r\n    while (match.test(this._str.charAt(this._currLocation + i))) {\r\n      i++;\r\n      if (i + this._currLocation > this._strLength) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this._currLocation += i;\r\n    return this._str.substr(this._currLocation - i, i);\r\n  }\r\n\r\n  protected eatWord(word: string): string {\r\n    let len = word.length;\r\n\r\n    if (this.peekAhead(len) === word) {\r\n      this._currLocation += len;\r\n      return word;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  protected eatUntil(match: RegExp): string {\r\n    let i = 0;\r\n\r\n    while (!match.test(this._str.charAt(this._currLocation + i))) {\r\n      i++;\r\n      if (i + this._currLocation > this._strLength) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this._currLocation += i;\r\n    return this._str.substr(this._currLocation - i, i);\r\n  }\r\n\r\n  protected peek(): string {\r\n    return this._str.charAt(this._currLocation);\r\n  }\r\n\r\n  protected peekAhead(by: number): string {\r\n    return this._str.substr(this._currLocation, by);\r\n  }\r\n\r\n  protected hasNext(): boolean {\r\n    return this._currLocation < this._strLength - 1;\r\n  }\r\n\r\n  /**\r\n   * Advances the stream if possible.\r\n   *\r\n   * @protected\r\n   * @returns {string} The token that was advanced over, or undefined if it wasn't possible to advance.\r\n   */\r\n  protected next(): string {\r\n    if (this.hasNext()) {\r\n      return this._str.charAt(this._currLocation++);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  protected reset(): void {\r\n    this._currLocation = 0;\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\..\\..\\src"}