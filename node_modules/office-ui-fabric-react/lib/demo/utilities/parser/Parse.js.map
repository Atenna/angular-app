{"version":3,"sources":["demo/utilities/parser/Parse.ts"],"names":[],"mappings":";AAAA,sBAAwC,wBAAwB,CAAC,CAAA;AACjE,sCAAsC,yBAAyB,CAAC,CAAA;AAChE,iCAAiC,oBAAoB,CAAC,CAAA;AAEtD;;;;;;;;;;;;;;GAcG;AACH,eAAsB,MAAc,EAAE,wBAAiC;IACrE,IAAI,KAAK,GAAgB,EAAE,CAAC;IAC5B,IAAI,KAAK,GAAW,IAAI,CAAC;IACzB,IAAI,SAAS,CAAC;IAEd,IAAI,kBAAkB,GAAG,UAAC,IAAY,IAAK,OAAA,IAAI,KAAK,WAAW,GAAG,YAAY,GAAG,OAAO,EAA7C,CAA6C,CAAC;IACzF,IAAI,YAAY,GAAG,UAAC,IAAY,IAAK,OAAA,IAAI,KAAK,WAAW,GAAG,oBAAY,CAAC,SAAS,GAAG,oBAAY,CAAC,IAAI,EAAjE,CAAiE,CAAC;IAEvG,EAAE,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC;QAC7B,KAAK,GAAG,IAAI,MAAM,CAAC,6BAA2B,wBAAwB,4CAAyC,CAAC,CAAC;QACjH,IAAI,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QACrC,EAAE,CAAC,CAAC,WAAW,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;YAC1C,SAAS,GAAG,qBAAqB,CAAC,WAAW,CAAC,CAAC;YAC/C,MAAM,CAAC,CAAY;oBACjB,IAAI,EAAE,wBAAwB;oBAC9B,YAAY,EAAE,wBAAwB,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC3E,YAAY,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC1C,QAAQ,EAAE,SAAS;iBACpB,CAAC,CAAC;QACL,CAAC;IACH,CAAC;IAAC,IAAI,CAAC,CAAC;QACN,KAAK,GAAG,IAAI,MAAM,CAAC,wEAAwE,EAAE,GAAG,CAAC,CAAC;QAClG,IAAI,WAAW,SAAiB,CAAC;QACjC,IAAI,OAAO,GAAqB,EAAE,CAAC;QACnC,OAAO,CAAC,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;YACnD,SAAS,GAAG,qBAAqB,CAAC,WAAW,CAAC,CAAC;YAC/C,OAAO,CAAC,IAAI,CAAY;gBACtB,IAAI,EAAE,WAAW,CAAC,CAAC,CAAC;gBACpB,YAAY,EAAE,WAAW,CAAC,CAAC,CAAC,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;gBACjE,YAAY,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;gBAC1C,QAAQ,EAAE,SAAS;aACpB,CAAC,CAAC;QACL,CAAC;QAED,MAAM,CAAC,OAAO,CAAC;IACjB,CAAC;IAED,MAAM,CAAC,KAAK,CAAC;AACf,CAAC;AAtCe,aAAK,QAsCpB,CAAA;AAED,+BAA+B,WAA4B;IACzD,IAAI,SAAS,CAAC;IACd,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,WAAW,CAAC,CAAC,CAAC;QACnC,IAAI,MAAM,GAAG,IAAI,6CAAqB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;QACvD,SAAS,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;QAC3B,MAAM,GAAG,IAAI,CAAC;IAChB,CAAC;IAAC,IAAI,CAAC,CAAC;QACN,IAAI,MAAM,GAAG,IAAI,mCAAgB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;QAClD,SAAS,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;QAC3B,MAAM,GAAG,IAAI,CAAC;IAChB,CAAC;IACD,MAAM,CAAC,SAAS,CAAC;AACnB,CAAC","file":"demo/utilities/parser/Parse.js","sourcesContent":["import { IProperty, PropertyType } from '../../components/index';\r\nimport { InterfaceParserHelper } from './InterfaceParserHelper';\r\nimport { EnumParserHelper } from './EnumParserHelper';\r\n\r\n/**\r\n * Given some valid, well linted Typescript source code, extracts exported interfaces and enums.\r\n *\r\n * Note: requires that the closing '}' of interfaces and enums is the first char on its own line.\r\n *       It should otherwise be reasonably robust to handle various commenting or even code layout\r\n *       styles within the interface or enum.\r\n *\r\n * To specify default values for interfaces, use the JSDoc @default or @defaultvalue markup.\r\n * The rest of the line after @default will be captured as the default value.\r\n *\r\n * @export\r\n * @param {string} source Valid, reasonably well linted Typescript source code.\r\n * @param {string} [propsInterfaceOrEnumName] Name of an interface or enum if you only want to parse said interface or enum.\r\n * @returns {Array<IProperty>} An array of properties.\r\n */\r\nexport function parse(source: string, propsInterfaceOrEnumName?: string): IProperty[] {\r\n  let props: IProperty[] = [];\r\n  let regex: RegExp = null;\r\n  let parseInfo;\r\n\r\n  let propertyNameSuffix = (type: string) => type === 'interface' ? ' interface' : ' enum';\r\n  let propertyType = (type: string) => type === 'interface' ? PropertyType.interface : PropertyType.enum;\r\n\r\n  if (propsInterfaceOrEnumName) {\r\n    regex = new RegExp(`export (interface|enum) ${propsInterfaceOrEnumName}(?: extends .*?)? \\\\{(.*[\\\\r\\\\n]*)*?\\\\}`);\r\n    let regexResult = regex.exec(source);\r\n    if (regexResult && regexResult.length > 0) {\r\n      parseInfo = _parseEnumOrInterface(regexResult);\r\n      return [<IProperty>{\r\n        name: propsInterfaceOrEnumName,\r\n        propertyName: propsInterfaceOrEnumName + propertyNameSuffix(regexResult[1]),\r\n        propertyType: propertyType(regexResult[1]),\r\n        property: parseInfo\r\n      }];\r\n    }\r\n  } else {\r\n    regex = new RegExp(`export (interface|enum) (\\\\S*?)(?: extends .*?)? \\\\{(.*[\\\\r\\\\n]*)*?\\\\}`, 'g');\r\n    let regexResult: RegExpExecArray;\r\n    let results: Array<IProperty> = [];\r\n    while ((regexResult = regex.exec(source)) !== null) {\r\n      parseInfo = _parseEnumOrInterface(regexResult);\r\n      results.push(<IProperty>{\r\n        name: regexResult[2],\r\n        propertyName: regexResult[2] + propertyNameSuffix(regexResult[1]),\r\n        propertyType: propertyType(regexResult[1]),\r\n        property: parseInfo\r\n      });\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  return props;\r\n}\r\n\r\nfunction _parseEnumOrInterface(regexResult: RegExpExecArray) {\r\n  let parseInfo;\r\n  if (regexResult[1] === 'interface') {\r\n    let parser = new InterfaceParserHelper(regexResult[0]);\r\n    parseInfo = parser.parse();\r\n    parser = null;\r\n  } else {\r\n    let parser = new EnumParserHelper(regexResult[0]);\r\n    parseInfo = parser.parse();\r\n    parser = null;\r\n  }\r\n  return parseInfo;\r\n}\r\n"],"sourceRoot":"..\\..\\..\\..\\src"}