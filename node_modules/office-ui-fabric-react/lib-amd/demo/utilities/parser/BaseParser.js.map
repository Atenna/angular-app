{"version":3,"sources":["demo/utilities/parser/BaseParser.ts"],"names":[],"mappings":";;IACA;;OAEG;IACH;QAKE,oBAAmB,IAAY;YAJvB,kBAAa,GAAG,CAAC,CAAC;YAKxB,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC;YACjB,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,MAAM,CAAC;QAChC,CAAC;QAES,wBAAG,GAAb,UAAc,KAAa;YACzB,EAAE,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,KAAK,KAAK,CAAC,CAAC,CAAC;gBACnD,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC;YAChD,CAAC;YAED,MAAM,CAAC,SAAS,CAAC;QACnB,CAAC;QAES,yCAAoB,GAA9B;YACE,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC,CAAC;QACvC,CAAC;QAES,6BAAQ,GAAlB,UAAmB,KAAa;YAC9B,IAAI,CAAC,GAAG,CAAC,CAAC;YAEV,OAAO,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC,KAAK,KAAK,EAAE,CAAC;gBAC1D,CAAC,EAAE,CAAC;gBACJ,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;oBAC7C,KAAK,CAAC;gBACR,CAAC;YACH,CAAC;YAED,IAAI,CAAC,aAAa,IAAI,CAAC,CAAC;YACxB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;QACrD,CAAC;QAES,kCAAa,GAAvB,UAAwB,KAAa;YACnC,IAAI,CAAC,GAAG,CAAC,CAAC;YAEV,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC5D,CAAC,EAAE,CAAC;gBACJ,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;oBAC7C,KAAK,CAAC;gBACR,CAAC;YACH,CAAC;YAED,IAAI,CAAC,aAAa,IAAI,CAAC,CAAC;YACxB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;QACrD,CAAC;QAES,4BAAO,GAAjB,UAAkB,IAAY;YAC5B,IAAI,GAAG,GAAG,IAAI,CAAC,MAAM,CAAC;YAEtB,EAAE,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,KAAK,IAAI,CAAC,CAAC,CAAC;gBACjC,IAAI,CAAC,aAAa,IAAI,GAAG,CAAC;gBAC1B,MAAM,CAAC,IAAI,CAAC;YACd,CAAC;YAED,MAAM,CAAC,SAAS,CAAC;QACnB,CAAC;QAES,6BAAQ,GAAlB,UAAmB,KAAa;YAC9B,IAAI,CAAC,GAAG,CAAC,CAAC;YAEV,OAAO,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC;gBAC7D,CAAC,EAAE,CAAC;gBACJ,EAAE,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC;oBAC7C,KAAK,CAAC;gBACR,CAAC;YACH,CAAC;YAED,IAAI,CAAC,aAAa,IAAI,CAAC,CAAC;YACxB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;QACrD,CAAC;QAES,yBAAI,GAAd;YACE,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC;QAC9C,CAAC;QAES,8BAAS,GAAnB,UAAoB,EAAU;YAC5B,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,EAAE,CAAC,CAAC;QAClD,CAAC;QAES,4BAAO,GAAjB;YACE,MAAM,CAAC,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,UAAU,GAAG,CAAC,CAAC;QAClD,CAAC;QAED;;;;;WAKG;QACO,yBAAI,GAAd;YACE,EAAE,CAAC,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;gBACnB,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,EAAE,CAAC,CAAC;YAChD,CAAC;YAED,MAAM,CAAC,SAAS,CAAC;QACnB,CAAC;QAES,0BAAK,GAAf;YACE,IAAI,CAAC,aAAa,GAAG,CAAC,CAAC;QACzB,CAAC;QACH,iBAAC;IAAD,CAxGA,AAwGC,IAAA;IAxGY,kBAAU,aAwGtB,CAAA","file":"demo/utilities/parser/BaseParser.js","sourcesContent":["\r\n/**\r\n * Base for a parser - does not actually do any parsing.\r\n */\r\nexport class BaseParser {\r\n  private _currLocation = 0;\r\n  private _str: string;\r\n  private _strLength: number;\r\n\r\n  public constructor(_str: string) {\r\n    this._str = _str;\r\n    this._strLength = _str.length;\r\n  }\r\n\r\n  protected eat(match: string): string {\r\n    if (this._str.charAt(this._currLocation) === match) {\r\n      return this._str.charAt(this._currLocation++);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  protected eatSpacesAndNewlines(): string {\r\n    return this.eatWhileRegex(/[ \\r\\n]/);\r\n  }\r\n\r\n  protected eatWhile(match: string): string {\r\n    let i = 0;\r\n\r\n    while (this._str.charAt(this._currLocation + i) === match) {\r\n      i++;\r\n      if (i + this._currLocation > this._strLength) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this._currLocation += i;\r\n    return this._str.substr(this._currLocation - i, i);\r\n  }\r\n\r\n  protected eatWhileRegex(match: RegExp): string {\r\n    let i = 0;\r\n\r\n    while (match.test(this._str.charAt(this._currLocation + i))) {\r\n      i++;\r\n      if (i + this._currLocation > this._strLength) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this._currLocation += i;\r\n    return this._str.substr(this._currLocation - i, i);\r\n  }\r\n\r\n  protected eatWord(word: string): string {\r\n    let len = word.length;\r\n\r\n    if (this.peekAhead(len) === word) {\r\n      this._currLocation += len;\r\n      return word;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  protected eatUntil(match: RegExp): string {\r\n    let i = 0;\r\n\r\n    while (!match.test(this._str.charAt(this._currLocation + i))) {\r\n      i++;\r\n      if (i + this._currLocation > this._strLength) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    this._currLocation += i;\r\n    return this._str.substr(this._currLocation - i, i);\r\n  }\r\n\r\n  protected peek(): string {\r\n    return this._str.charAt(this._currLocation);\r\n  }\r\n\r\n  protected peekAhead(by: number): string {\r\n    return this._str.substr(this._currLocation, by);\r\n  }\r\n\r\n  protected hasNext(): boolean {\r\n    return this._currLocation < this._strLength - 1;\r\n  }\r\n\r\n  /**\r\n   * Advances the stream if possible.\r\n   *\r\n   * @protected\r\n   * @returns {string} The token that was advanced over, or undefined if it wasn't possible to advance.\r\n   */\r\n  protected next(): string {\r\n    if (this.hasNext()) {\r\n      return this._str.charAt(this._currLocation++);\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  protected reset(): void {\r\n    this._currLocation = 0;\r\n  }\r\n}\r\n"],"sourceRoot":"..\\..\\..\\..\\src"}