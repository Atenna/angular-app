{"version":3,"sources":["demo/utilities/parser/Parse.ts"],"names":[],"mappings":";;IAIA;;;;;;;;;;;;;;OAcG;IACH,eAAsB,MAAc,EAAE,wBAAiC;QACrE,IAAI,KAAK,GAAgB,EAAE,CAAC;QAC5B,IAAI,KAAK,GAAW,IAAI,CAAC;QACzB,IAAI,SAAS,CAAC;QAEd,IAAI,kBAAkB,GAAG,UAAC,IAAY,IAAK,OAAA,IAAI,KAAK,WAAW,GAAG,YAAY,GAAG,OAAO,EAA7C,CAA6C,CAAC;QACzF,IAAI,YAAY,GAAG,UAAC,IAAY,IAAK,OAAA,IAAI,KAAK,WAAW,GAAG,oBAAY,CAAC,SAAS,GAAG,oBAAY,CAAC,IAAI,EAAjE,CAAiE,CAAC;QAEvG,EAAE,CAAC,CAAC,wBAAwB,CAAC,CAAC,CAAC;YAC7B,KAAK,GAAG,IAAI,MAAM,CAAC,6BAA2B,wBAAwB,4CAAyC,CAAC,CAAC;YACjH,IAAI,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;YACrC,EAAE,CAAC,CAAC,WAAW,IAAI,WAAW,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC1C,SAAS,GAAG,qBAAqB,CAAC,WAAW,CAAC,CAAC;gBAC/C,MAAM,CAAC,CAAY;wBACjB,IAAI,EAAE,wBAAwB;wBAC9B,YAAY,EAAE,wBAAwB,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;wBAC3E,YAAY,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;wBAC1C,QAAQ,EAAE,SAAS;qBACpB,CAAC,CAAC;YACL,CAAC;QACH,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,KAAK,GAAG,IAAI,MAAM,CAAC,wEAAwE,EAAE,GAAG,CAAC,CAAC;YAClG,IAAI,WAAW,SAAiB,CAAC;YACjC,IAAI,OAAO,GAAqB,EAAE,CAAC;YACnC,OAAO,CAAC,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,KAAK,IAAI,EAAE,CAAC;gBACnD,SAAS,GAAG,qBAAqB,CAAC,WAAW,CAAC,CAAC;gBAC/C,OAAO,CAAC,IAAI,CAAY;oBACtB,IAAI,EAAE,WAAW,CAAC,CAAC,CAAC;oBACpB,YAAY,EAAE,WAAW,CAAC,CAAC,CAAC,GAAG,kBAAkB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBACjE,YAAY,EAAE,YAAY,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC;oBAC1C,QAAQ,EAAE,SAAS;iBACpB,CAAC,CAAC;YACL,CAAC;YAED,MAAM,CAAC,OAAO,CAAC;QACjB,CAAC;QAED,MAAM,CAAC,KAAK,CAAC;IACf,CAAC;IAtCe,aAAK,QAsCpB,CAAA;IAED,+BAA+B,WAA4B;QACzD,IAAI,SAAS,CAAC;QACd,EAAE,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC,KAAK,WAAW,CAAC,CAAC,CAAC;YACnC,IAAI,MAAM,GAAG,IAAI,6CAAqB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;YACvD,SAAS,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;YAC3B,MAAM,GAAG,IAAI,CAAC;QAChB,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,IAAI,MAAM,GAAG,IAAI,mCAAgB,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC;YAClD,SAAS,GAAG,MAAM,CAAC,KAAK,EAAE,CAAC;YAC3B,MAAM,GAAG,IAAI,CAAC;QAChB,CAAC;QACD,MAAM,CAAC,SAAS,CAAC;IACnB,CAAC","file":"demo/utilities/parser/Parse.js","sourcesContent":["import { IProperty, PropertyType } from '../../components/index';\r\nimport { InterfaceParserHelper } from './InterfaceParserHelper';\r\nimport { EnumParserHelper } from './EnumParserHelper';\r\n\r\n/**\r\n * Given some valid, well linted Typescript source code, extracts exported interfaces and enums.\r\n *\r\n * Note: requires that the closing '}' of interfaces and enums is the first char on its own line.\r\n *       It should otherwise be reasonably robust to handle various commenting or even code layout\r\n *       styles within the interface or enum.\r\n *\r\n * To specify default values for interfaces, use the JSDoc @default or @defaultvalue markup.\r\n * The rest of the line after @default will be captured as the default value.\r\n *\r\n * @export\r\n * @param {string} source Valid, reasonably well linted Typescript source code.\r\n * @param {string} [propsInterfaceOrEnumName] Name of an interface or enum if you only want to parse said interface or enum.\r\n * @returns {Array<IProperty>} An array of properties.\r\n */\r\nexport function parse(source: string, propsInterfaceOrEnumName?: string): IProperty[] {\r\n  let props: IProperty[] = [];\r\n  let regex: RegExp = null;\r\n  let parseInfo;\r\n\r\n  let propertyNameSuffix = (type: string) => type === 'interface' ? ' interface' : ' enum';\r\n  let propertyType = (type: string) => type === 'interface' ? PropertyType.interface : PropertyType.enum;\r\n\r\n  if (propsInterfaceOrEnumName) {\r\n    regex = new RegExp(`export (interface|enum) ${propsInterfaceOrEnumName}(?: extends .*?)? \\\\{(.*[\\\\r\\\\n]*)*?\\\\}`);\r\n    let regexResult = regex.exec(source);\r\n    if (regexResult && regexResult.length > 0) {\r\n      parseInfo = _parseEnumOrInterface(regexResult);\r\n      return [<IProperty>{\r\n        name: propsInterfaceOrEnumName,\r\n        propertyName: propsInterfaceOrEnumName + propertyNameSuffix(regexResult[1]),\r\n        propertyType: propertyType(regexResult[1]),\r\n        property: parseInfo\r\n      }];\r\n    }\r\n  } else {\r\n    regex = new RegExp(`export (interface|enum) (\\\\S*?)(?: extends .*?)? \\\\{(.*[\\\\r\\\\n]*)*?\\\\}`, 'g');\r\n    let regexResult: RegExpExecArray;\r\n    let results: Array<IProperty> = [];\r\n    while ((regexResult = regex.exec(source)) !== null) {\r\n      parseInfo = _parseEnumOrInterface(regexResult);\r\n      results.push(<IProperty>{\r\n        name: regexResult[2],\r\n        propertyName: regexResult[2] + propertyNameSuffix(regexResult[1]),\r\n        propertyType: propertyType(regexResult[1]),\r\n        property: parseInfo\r\n      });\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  return props;\r\n}\r\n\r\nfunction _parseEnumOrInterface(regexResult: RegExpExecArray) {\r\n  let parseInfo;\r\n  if (regexResult[1] === 'interface') {\r\n    let parser = new InterfaceParserHelper(regexResult[0]);\r\n    parseInfo = parser.parse();\r\n    parser = null;\r\n  } else {\r\n    let parser = new EnumParserHelper(regexResult[0]);\r\n    parseInfo = parser.parse();\r\n    parser = null;\r\n  }\r\n  return parseInfo;\r\n}\r\n"],"sourceRoot":"..\\..\\..\\..\\src"}