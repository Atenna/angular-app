{"version":3,"sources":["utilities/selection/Selection.test.ts"],"names":[],"mappings":"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","file":"utilities/selection/Selection.test.js","sourcesContent":["let { expect } = chai;\r\n\r\nimport { Selection, IObjectWithKey } from './index';\r\n\r\nlet setA = [ { key: 'a' }, { key: 'b' }, { key: 'c' } ];\r\nlet setB = [ { key: 'a' }, { key: 'd' }, { key: 'b' } ];\r\n\r\ndescribe('Selection', () => {\r\n\r\n  it('fires change events only when selection changes occur', () => {\r\n    let changeCount = 0;\r\n    let selection = new Selection({ onSelectionChanged: () => changeCount++ });\r\n\r\n    selection.setItems(setA, false);\r\n    expect(changeCount).equals(0, 'after setting set a');\r\n\r\n    selection.setKeySelected('a', true, true);\r\n    selection.setKeySelected('a', true, true);\r\n    selection.setIndexSelected(0, true, true);\r\n    expect(changeCount).equals(1, 'after selecting item a');\r\n\r\n    // Switch to set b, which also contains item a, in the same position. No change event should occur.\r\n    selection.setItems(setB, false);\r\n    expect(changeCount).equals(1, 'after switching to set b');\r\n\r\n    // Select b\r\n    selection.setKeySelected('b', true, true);\r\n    expect(changeCount).equals(2, 'after selecting b');\r\n\r\n    // Change back to set a, which has item b in a different index.\r\n    selection.setItems(setA, false);\r\n    expect(changeCount).equals(3, 'after changing back to set a');\r\n\r\n    // Change to set b, but clear it.\r\n    selection.setItems(setB, true);\r\n    expect(changeCount).equals(4, 'after switching to set b and clearing');\r\n\r\n    // Select an item in set b that doesn't exist in set a, then switch to set a.\r\n    selection.setKeySelected('d', true, true);\r\n    selection.setItems(setA, false);\r\n    expect(changeCount).equals(6, 'after selecting c and switching to set a');\r\n\r\n    // Select an item, clear, clear again.\r\n    selection.setAllSelected(true);\r\n    selection.setAllSelected(true);\r\n    selection.setAllSelected(false);\r\n    selection.setAllSelected(false);\r\n    expect(changeCount).equals(8, 'after selecting all 2 times and clearing 2 times');\r\n\r\n    selection.setIndexSelected(0, true, true);\r\n    selection.selectToIndex(2, true);\r\n    expect(changeCount).equals(10, 'after range selecting from 0 to 2');\r\n  });\r\n\r\n  it('returns false on isAllSelected when no items are selectable', () => {\r\n    let changeEvents = 0;\r\n    let selection = new Selection({\r\n      canSelectItem: (item: IObjectWithKey) => false,\r\n      onSelectionChanged: () => changeEvents++\r\n    });\r\n\r\n    selection.setItems(setA);\r\n\r\n    expect(selection.isAllSelected()).to.equal(false, 'isAllSelected was not false after initialization');\r\n\r\n    selection.setAllSelected(true);\r\n\r\n    expect(selection.isAllSelected()).to.equal(false, 'isAllSelected was not false after trying to select all the unselectables');\r\n\r\n    expect(changeEvents).to.equal(0, 'changeEvents were not 0');\r\n  });\r\n\r\n  it ('resets unselectable count on setting new items', () => {\r\n    let canSelect = false;\r\n    let selection = new Selection({\r\n      canSelectItem: (item: IObjectWithKey) => canSelect\r\n    });\r\n\r\n    selection.setItems(setA);\r\n    expect(selection.isAllSelected()).to.equal(false, 'isAllSelected was not false after initialization');\r\n    selection.setAllSelected(true);\r\n    expect(selection.isAllSelected()).to.equal(false, 'isAllSelected was not false after trying to select all the unselectables');\r\n\r\n    canSelect = true;\r\n    selection.setItems(setA);\r\n    selection.setAllSelected(true);\r\n    expect(selection.isAllSelected()).to.equal(true, 'isAllSelected was not false after trying to select all the unselectables');\r\n  });\r\n\r\n});"],"sourceRoot":"..\\..\\..\\src"}